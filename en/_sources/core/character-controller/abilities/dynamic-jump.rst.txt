.. _dynamic-jump-page:

Dynamic Jump
============

This component is used to perform dynamic jumps, meaning it manipulates a ``RigidBody2D`` set as dynamic
to achieve its goal.

What it requires
----------------

* There must be a ``RigidBody2D`` component among its ``GameObject`` other components.

What it Implements
------------------

.. table:: 
   :width: 100% 
   :widths: 100

   +-----------------------------------------------------------------------------------------------------+
   | **Interface**                                                                                       |
   +-----------------------------------------------------------------------------------------------------+
   | :ref:`IJumpPerformer <i-jump-perfomer-page>`                                                        |
   +-----------------------------------------------------------------------------------------------------+
   | :ref:`IJumpExtraPerformer <i-jump-extra-perfomer-page>`                                             |
   +-----------------------------------------------------------------------------------------------------+

Seeks For
---------

Below you will find what you should feed this component with and how. You can always do it by directly accessing its methods 
or having components wich provide what they need and mark this component to seek for them through the inspector window.

Grounding
*********

This component needs to know if its ``GameObject`` can be considered grounded to reset extra jump count.

You can use the ``UpdateGrounding(bool newGrounding)`` method every update or mark the component to seek for an 
:ref:`IGroundingProvider <i-grounding-provider-page>` as long as it has some component wich implements 
it among its ``GameObject`` other components. Our :ref:`Grounding Checker <grounding-checker-page>` implements it.

Wall Hit Data
*************

This component needs to know if its ``GameObject`` can be considered hitting walls to reset extra jump count.

You can use the ``UpdateWallHitData(WallHitData newWallHitData)`` method every update or mark the component to seek for an 
:ref:`IWallHitDataProvider <i-wall-hit-data-provider-page>` as long as it has some component wich implements 
it among its ``GameObject`` other components. Our :ref:`Wall Hit Checker <wall-hit-checker-page>` implements it.

Movement Directions
*******************

This component needs to know if it is sliding on a wall to be able to perform wall jumps. For that we need the current movement
direction.

You can use the ``UpdateMovementDirection(Vector2 newMovementDirection)`` method every update or mark the component to seek for an 
:ref:`IMovementDirectionsProvider <i-movement-directions-provider-page>` as long as it has some component wich implements 
it among its ``GameObject`` other components.

Jump Handler
************

This component needs to told when to perform its jumps and extra jumps. So you will need a component to do that.

You can use the ``Request()``, ``Stop()``, methods as seen below on the "How to use" section.
You also can mark it to seek for an :ref:`IJumpHandler <i-jump-handler-page>` as long as it has some 
component wich implements it among its ``GameObject`` other components. If you opt to do so, the IJumpHandler component will 
take care of calling the ``Request()`` and ``Stop()`` methods when needed.

Usage
-----

Here is how you can use this component:

Direct approach
***************

.. code-block:: csharp

    DynamicJump jump;

    void Awake() 
    {
        jump = GetComponent<DynamicJump>();
    }

    void Update() 
    {
        if (Input.GetButtonDown("Jump"))
        {
            jump.Request();
        }

        if (Input.GetButtonUp("Jump"))
        {
            jump.Stop();
        }
    }

    void FixedUpdate()
    {
        if (jump.jumping)
        {
            jump.Perform();
        }
    }

Listening to IJumpPerformer and IJumpExtraPerformer events
**********************************************************

.. code-block:: csharp

    // This is an example on how to listen to the DynamicJump events using other components 
    // you might craft

    IJumpPerformer jumpPerformer;
    IJumpExtraPerformer jumpExtraPerformer;

    void Awake()
    {
        jumpPerformer = GetComponent<IJumpPerformer>();    
        jumpExtraPerformer = GetComponent<IJumpExtraPerformer>();    
    }

    void Start()
    {
        jumpPerformer?.JumpPerformed.AddListener(OnJumpPerfomed);
        jumpExtraPerformer?.ExtraJumpPerformed.AddListener(OnJumpExtraPerfomed);
    }

    void OnDisable()
    {
        jumpPerformer?.JumpPerformed.RemoveListener(OnJumpPerfomed);
        jumpExtraPerformer?.ExtraJumpPerformed.RemoveListener(OnJumpExtraPerfomed);
    }
    
    void OnJumpPerfomed(GameObject go)
    {
        // Your logic
    }
    
    void OnJumpExtraPerfomed(GameObject go)
    {
        // Your logic
    }

The reason for 2 separate interfaces for jumps and extra jumps is so you can separate the logic for the two.
Sometimes you might want to have the extra jump to be shorter, higher or different in some other way and even 
animate then differently. This is also reflected in the setup.

.. note::

    You can also use the direct approach to listen to the events.

Setup
*****

.. code-block:: csharp

    namespace Handy2DTools.CharacterController.Abilities
    {
        [CreateAssetMenu(fileName = "New DynamicJumpSetup", menuName = "Handy 2D Tools/CharacterController/Setups/DynamicJump")]
        public class DynamicJumpSetup : AbilitySetup
        {
            #region Inspector

            [Header("Jump Setup")]
            [Tooltip("The amount of force wich will be proportionaly applyed to Y axis.")]
            [SerializeField]
            [Space]
            protected float force = 100f;

            [Tooltip("The top speed character can reach while ascending.")]
            [SerializeField]
            protected float maxYSpeed = 10f;

            [Label("Impulse Duration")]
            [Tooltip("Period of time in seconds during which force will be applyed positively to Y axis.")]
            [SerializeField]
            protected float duration = 0.35f;

            [Header("Coyote Time")]
            [Tooltip("Mark this if you want coyote time to be applyed.")]
            [SerializeField]
            protected bool hasCoyoteTime = false;

            [Label("Coyote Time Rate")]
            [Tooltip("Used to calculate for how long character can still jump in case of not being grounded anymore.")]
            [ShowIf("hasCoyoteTime")]
            [SerializeField]
            protected float coyoteTime = 0.15f;

            [Header("Jump Buffer")]
            [Label("Jump Buffer Rate")]
            [Tooltip("Used to allow character jumping even though a jump request has been made before it is considered grounded.")]
            [SerializeField]
            protected float jumpBufferTime = 0.15f;

            [Header("Wall jumps")]
            [Label("Can Wall Jump")]
            [Tooltip("Mark this if character can jump from a wall.")]
            [SerializeField]
            protected bool canWallJump = false;

            [Header("Extra Jumps")]
            [Label("Has Extra Jumps")]
            [SerializeField]
            protected bool hasExtraJumps = false;

            [Tooltip("The amount of extra jumps the character can acumulate to perform sequentially after main jump")]
            [ShowIf("hasExtraJumps")]
            [SerializeField]
            protected int extraJumps = 1;

            [Tooltip("The amount of force wich will be proportionaly applyed to Y axis.")]
            [ShowIf("hasExtraJumps")]
            [SerializeField]
            protected float extraJumpForce = 100f;

            [Tooltip("Period of time in seconds during which force will be applyed positively to Y axis.")]
            [ShowIf("hasExtraJumps")]
            [SerializeField]
            protected float extraJumpDuration = 0.35f;

            [Foldout("Jump Events")]
            [Label("Jump Performed")]
            [Space]
            [SerializeField]
            protected UnityEvent<GameObject> jumpPerformed;

            [Foldout("Jump Events")]
            [Label("Extra Jump Performed")]
            [SerializeField]
            protected UnityEvent<GameObject> extraJumpPerformed;

            #endregion

            #region Getters

            public float Force => force;
            public float MaxYSpeed => maxYSpeed;
            public float Duration => duration;
            public bool HasCoyoteTime => hasCoyoteTime;
            public float CoyoteTime => coyoteTime;
            public float JumpBufferTime => jumpBufferTime;
            public bool CanWallJump => canWallJump;
            public bool HasExtraJumps => hasExtraJumps;
            public int ExtraJumps => extraJumps;
            public float ExtraJumpForce => extraJumpForce;
            public float ExtraJumpDuration => extraJumpDuration;
            public UnityEvent<GameObject> JumpPerformed => jumpPerformed;
            public UnityEvent<GameObject> ExtraJumpPerformed => extraJumpPerformed;

            #endregion
        }
    }

The perform approach
--------------------

On this ability's inspector you can mark ``Auto Perform`` checkbox and the component will perform automatically upon 
self resolving jump requests and stops.

In case you are working with an FSM (we have one, checkout  our :ref:`FSM solution <welcome-core-fsm-page>`) you might want
your state to call the ``Perform()`` and ``PerformExtraJump()`` methods.

Locking Jumps
-------------

Use the method ``LockJump(bool shouldLock)`` to prevent or allow jumps to be performed. Great to be used with FSMs 
when entering and leaving states on wich jump should not be started.

Coyote Time 
-----------

On this ability's setup you can define a Coyote Time wich will be used to allow character to still start a jump 
after no long being grounded.

Jump Buffer 
-----------

Set this into the ability's setup to define how long before actually hitting ground player can press the jump 
button (meaning a request will be sent to this component). 

Available Methods
-----------------

.. code-block:: csharp

    // Call this on physics update to tell the ability to perform its current
    // on going jump.    
    public void Perform()
    
    // Call this on physics update to tell the ability to perform its current
    // on going extra jump.    
    public void PerformExtraJump()

    // Call this upon detecting the extra jump count should be reset
    public virtual void RequestJumpCountReset()

    // Call this in order to request a jump. The component will 
    // self evaluate if it can jump or not as well as if it should be 
    // a regular jump or an extra jump.
    public virtual void Request()
    
    // Call this in order to stop the current on going jump 
    // or extra jump.
    public void Stop()

    // Call this to update grounding
    public void UpdateGrounding(bool newGrounding)

    // Call this to update Wall Hit Data
    public void UpdateWallHitData(WallHitData newWallHitData)

    // Call this to update Movement Direction
    public void UpdateMovementDirection(Vector2 newMovementDirection)

    // Call this to lock or release the ability to jump
    public void LockJump(bool shouldLock)